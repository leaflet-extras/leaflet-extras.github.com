{"ts":1363890727861,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1363890766790,"patch":[[{"diffs":[[1,"(function() {\r\n\r\n  L.Hash = L.Class.extend({\r\n    initialize: function(map, options) {\r\n      this.map = map;\r\n      this.options = options || {};\r\n      if (!this.options.path) {\r\n        if (this.options.lc) {\r\n          this.options.path = '{base}/{z}/{lat}/{lng}';\r\n        } else {\r\n          this.options.path = '{z}/{lat}/{lng}';\r\n        }\r\n      }\r\n      if (this.options.lc && !this.options.formatBase) {\r\n        this.options.formatBase = [\r\n          /[\\sA-Z]/g, function(match) {\r\n            if (match.match(/\\s/)) {\r\n              return \"_ \";\r\n            }\r\n            if (match.match(/[A-Z]/)) {\r\n              return match.toLowerCase();\r\n            }\r\n          }\r\n        ];\r\n      }\r\n      if (this.map._loaded) {\r\n        return this.startListning();\r\n      } else {\r\n        return this.map.on(\"load\", this.startListning);\r\n      }\r\n    },\r\n    startListning: function() {\r\n      var onHashChange,\r\n        _this = this;\r\n      if (location.hash) {\r\n        this.updateFromState(this.parseHash(location.hash));\r\n      }\r\n      if (history.pushState) {\r\n        if (!location.hash) {\r\n          history.replaceState.apply(history, this.formatState());\r\n        }\r\n        window.onpopstate = function(event) {\r\n          if (event.state) {\r\n            return _this.updateFromState(event.state);\r\n          }\r\n        };\r\n        this.map.on(\"moveend\", function() {\r\n          var pstate;\r\n          pstate = _this.formatState();\r\n          if (location.hash !== pstate[2] && !_this.moving) {\r\n            return history.pushState.apply(history, pstate);\r\n          }\r\n        });\r\n      } else {\r\n        if (!location.hash) {\r\n          location.hash = this.formatState()[2];\r\n        }\r\n        onHashChange = function() {\r\n          var pstate;\r\n          pstate = _this.formatState();\r\n          if (location.hash !== pstate[2] && !_this.moving) {\r\n            return location.hash = pstate[2];\r\n          }\r\n        };\r\n        this.map.on(\"moveend\", onHashChange);\r\n        if (('onhashchange' in window) && (window.documentMode === void 0 || window.documentMode > 7)) {\r\n          window.onhashchange = function() {\r\n            if (location.hash) {\r\n              return _this.updateFromState(_this.parseHash(location.hash));\r\n            }\r\n          };\r\n        } else {\r\n          this.hashChangeInterval = setInterval(onHashChange, 50);\r\n        }\r\n      }\r\n      return this.map.on(\"baselayerchange\", function(e) {\r\n        var pstate, _ref;\r\n        _this.base = (_ref = _this.options.lc._layers[e.layer._leaflet_id].name).replace.apply(_ref, _this.options.formatBase);\r\n        pstate = _this.formatState();\r\n        if (history.pushState) {\r\n          if (location.hash !== pstate[2] && !_this.moving) {\r\n            return history.pushState.apply(history, pstate);\r\n          }\r\n        } else {\r\n          if (location.hash !== pstate[2] && !_this.moving) {\r\n            return location.hash = pstate[2];\r\n          }\r\n        }\r\n      });\r\n    },\r\n    parseHash: function(hash) {\r\n      var args, lat, latIndex, lngIndex, lon, out, path, zIndex, zoom;\r\n      path = this.options.path.split(\"/\");\r\n      zIndex = path.indexOf(\"{z}\");\r\n      latIndex = path.indexOf(\"{lat}\");\r\n      lngIndex = path.indexOf(\"{lng}\");\r\n      if (hash.indexOf(\"#\") === 0) {\r\n        hash = hash.substr(1);\r\n      }\r\n      args = hash.split(\"/\");\r\n      if (args.length > 2) {\r\n        zoom = parseInt(args[zIndex], 10);\r\n        lat = parseFloat(args[latIndex]);\r\n        lon = parseFloat(args[lngIndex]);\r\n        if (isNaN(zoom) || isNaN(lat) || isNaN(lon)) {\r\n          return false;\r\n        } else {\r\n          out = {\r\n            center: new L.LatLng(lat, lon),\r\n            zoom: zoom\r\n          };\r\n          if (args.length > 3) {\r\n            out.base = args[path.indexOf(\"{base}\")];\r\n            return out;\r\n          } else {\r\n            return out;\r\n          }\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n    updateFromState: function(state) {\r\n      if (this.moving) {\r\n        return;\r\n      }\r\n      this.moving = true;\r\n      this.map.setView(state.center, state.zoom);\r\n      if (state.base) {\r\n        this.setBase(state.base);\r\n      }\r\n      this.moving = false;\r\n      return true;\r\n    },\r\n    formatState: function() {\r\n      var center, precision, state, template, zoom;\r\n      center = this.map.getCenter();\r\n      zoom = this.map.getZoom();\r\n      precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));\r\n      state = {\r\n        center: center,\r\n        zoom: zoom\r\n      };\r\n      template = {\r\n        lat: center.lat.toFixed(precision),\r\n        lng: center.lng.toFixed(precision),\r\n        z: zoom\r\n      };\r\n      if (this.options.path.indexOf(\"{base}\") > -1) {\r\n        state.base = this.getBase();\r\n        template.base = state.base;\r\n      }\r\n      return [state, \"a\", '#' + L.Util.template(this.options.path, template)];\r\n    },\r\n    setBase: function(base) {\r\n      var i, inputs, len, _ref;\r\n      this.base = base;\r\n      inputs = this.options.lc._form.getElementsByTagName('input');\r\n      len = inputs.length;\r\n      i = 0;\r\n      while (i < len) {\r\n        if (inputs[i].name === 'leaflet-base-layers' && (_ref = this.options.lc._layers[inputs[i].layerId].name).replace.apply(_ref, this.options.formatBase) === base) {\r\n          inputs[i].checked = true;\r\n          this.options.lc._onInputClick();\r\n          return true;\r\n        }\r\n        i++;\r\n      }\r\n    },\r\n    getBase: function() {\r\n      var i, inputs, len, _ref;\r\n      if (this.base) {\r\n        return this.base;\r\n      }\r\n      inputs = this.options.lc._form.getElementsByTagName('input');\r\n      len = inputs.length;\r\n      i = 0;\r\n      while (i < len) {\r\n        if (inputs[i].name === 'leaflet-base-layers' && inputs[i].checked) {\r\n          this.base = (_ref = this.options.lc._layers[inputs[i].layerId].name).replace.apply(_ref, this.options.formatBase);\r\n          return this.base;\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n    remove: function() {\r\n      this.map.off(\"moveend\");\r\n      if (window.onpopstate) {\r\n        window.onpopstate = null;\r\n      }\r\n      location.hash = \"\";\r\n      return clearInterval(this.hashChangeInterval);\r\n    }\r\n  });\r\n\r\n  L.hash = function(map, options) {\r\n    return new L.Hash(map, options);\r\n  };\r\n\r\n  L.Map.include({\r\n    addHash: function(options) {\r\n      if (this._loaded) {\r\n        this._hash = L.hash(this, options);\r\n      } else {\r\n        this.on(\"load\", function() {\r\n          return this._hash = L.hash(this, options);\r\n        });\r\n      }\r\n      return this;\r\n    },\r\n    removeHash: function() {\r\n      this._hash.remove();\r\n      return this;\r\n    }\r\n  });\r\n\r\n}).call(this);"]],"start1":0,"start2":0,"length1":0,"length2":6713}]],"length":6713,"saved":false}
